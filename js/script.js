// 0 Блок объявления const, дальнейшея нумерация сделана относительно вызова, а не объявления
// 4.1 Функция фильтрации, принимает тип и с помощью Rest оператора преобразает,
// получаемую строку в массив, к которому применяет метод filter,
// функция возвращает массив из тех элементов тип которых совподает с заданным значением.
// или пустой массив если таких аргументов не найдено.
const filterByType = (type, ...values) => values.filter(value => typeof value === type),
// 5.1 Функция скрывающая все блоки вывода результата.
	hideAllResponseBlocks = () => {
		// 5.1.1 Получает в переменную responseBlocksArray массив блоков отображения результата
		// перобразуя его из коллекции полученных по общему для этих блоков селектору
		const responseBlocksArray = Array.from(document.querySelectorAll('div.dialog__response-block'));
		// 5.1.2 Перебираем массив с блоками меняя свойсто .style.display на none у каждого болка
		responseBlocksArray.forEach(block => block.style.display = 'none');
	},
	// 4.1 Функция отображения блоков с результатом, примает селектор, текст сообщения 
	showResponseBlock = (blockSelector, msgText, spanSelector) => {
		// 4.1.1 Функция скрывает все блоки с выводом результата
		hideAllResponseBlocks();
		// 4.1.2 Получаем болк по селектору и отборажаем его на странице,
		// меняя .style.display с none которое было присвоено в пердыдущей строке на block
		document.querySelector(blockSelector).style.display = 'block';
		// 4.1.3 Проверяем передан ли селектор элемента в котором будет отображатся сообщение о
		// результате работа функции filterByType
		if (spanSelector) {
			// 4.1.3.1 Выводим сообщение о результате работа функции filterByType
			document.querySelector(spanSelector).textContent = msgText;
		}
	},
	// 8.1 Функция отображает блок ошибок, в случае если произошла ошибка,
	// при выполнении функции filterByType, а именно были переданны некоректные аргументы,
	// или того хуже там где должны быть аргументы стоит неизвестное выражение
	showError = msgText => showResponseBlock('.dialog__response-block_error', msgText, '#error'),
	// 7.1 Функция отображает результат работы функции filterByType
	showResults = msgText => showResponseBlock('.dialog__response-block_ok', msgText, '#ok'),
	// 2.1 Функция отображения стартового блока, без результата,
	// вызавается в случае нажатия на кнопку Фильтровать" при вустом поле ввода,
	// вызвает функию отображения блоков showResponseBlock, качестве аргумента отправляет селектор,
	// с классом блока без результата
	showNoResults = () => showResponseBlock('.dialog__response-block_no-results'),
	// 6.1 Функция tryFilterByType - получает значения из формы ввиде аргументов,
	// и запуска функцию фильтрации filterByType в своем теле,
	// если при выполнении filterByType, произойдет ошибка, не остановить исполнение кода,
	// а вызовет функцию отображения результата - ошибки.
	tryFilterByType = (type, values) => {
		// 6.1.1 Основной функциональный код
		try {
			// 6.1.1.1 eval запускает из строки (использовать ее по хорошему нельзя,
			// так как она очень не безопаска, но для демонстрации работы с ошибками она подойдет)
			// filterByType передавая в качестве аргументов в нее две строки,
			// результатом вызова функции должен быть массив, который с помощью join собераем в строку,
			// либо произойдет ошибка, если в строка знечения содержит в себе не обренутые в ковычки символы
			// в этом случае они бедут приняты за переменные или неуместные в качестве аргументов выражения,
			// тогда выполнение тела фунции прервется и отработает catch
			const valuesArray = eval(`filterByType('${type}', ${values})`).join(", ");
			// 6.1.1.2 Если не произошло ошибки строкой выше, формируем сообщение отображения результата
			// работы функции, если строка valuesArray не пуста, то выводим сообщение с типом type и
			// отфильтрованной строкой значенией valuesArray, в противном случае выводим,
			// что данный с таким типом отсутствуют. Зачем сспользовать length в условии загадка номер 3...
			const alertMsg = (valuesArray.length) ?
				`Данные с типом ${type}: ${valuesArray}` :
				`Отсутствуют данные типа ${type}`;
			// 6.1.1.3 Функция вывода результата на экран
			showResults(alertMsg);
		} catch (e) {
			// 6.1.1.4 Функция отображения ошибки, в качестве аргумента получает строку с ошибкой
			showError(`Ошибка: ${e}`);
		}
	};

// 1.1 Получаем кнопку "Фильтровать"
const filterButton = document.querySelector('#filter-btn');
// 1.2 Вешаем на кнопку слушетель onClick
filterButton.addEventListener('click', e => {
	// 1.2.1 Плолучаем select и input
	const typeInput = document.querySelector('#type');
	const dataInput = document.querySelector('#data');
	// 1.2.2 Проверяем введено ли значение в поле ввода
	if (dataInput.value === '') {
		// 1.2.2.1.1 Задаем сообщение стандартной валидации
		dataInput.setCustomValidity('Поле не должно быть пустым!');
		// 1.2.2.1.2 Отображаем стартовый блок без результата работы функции фильтрации
		showNoResults();
	} else {
		// 1.2.2.2.1 Зачем мы очищаем сообщение понятия не имею, 
		// так как оно не выводится и все работает,
		// даже если закоментировать следующую строку,
		// видимо на всякий случай...
		dataInput.setCustomValidity('');
		// 1.2.2.2.2 Отменяем стандартные действия браузера, тоесть не пытаемся отправить форму
		e.preventDefault();
		// 1.2.2.2.3 Вызаваем функцию фильтрации с парамметрами type и data,
		// точнее не совсем так, это функция не дообертка функции фильтрации,
		// которая отлавлявает произошедшие ошибки, использует конструкцию try ... catch
		// НО не останавливает исполнение скрипта, а дает возможность обработать произошедшие событие
		// PS: зачем тримить typeInput.value загадка номер 2, там пользователь не мог накасячить...
		tryFilterByType(typeInput.value.trim(), dataInput.value.trim());
	}
});
